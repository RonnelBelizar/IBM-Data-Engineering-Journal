# Topic: Module 3 â€” - Intermediate SQL

---

# ðŸ”  Using String Patterns and Ranges â€” Find Data Like a Pro!

Sometimes, you donâ€™t know *exactly* what youâ€™re looking for â€” you just know a **pattern**, a **range**, or a **set** of possible values.  
SQLâ€™s got you covered! ðŸŽ¯  
Letâ€™s explore how to use **string patterns**, **ranges**, and **sets** to make your searches smart and flexible.

---

## ðŸ” String Pattern Matching

You can use the **LIKE predicate** to find values that *match a pattern* â€” great for searching text thatâ€™s close, but not exact.

**Syntax:**  
`"SELECT column_name FROM table_name WHERE column_name LIKE 'pattern';"`

### ðŸŽ­ Wildcard Characters
Wildcards help you define flexible search patterns.

| Wildcard | Meaning                            | Example           | Matches                                      |
|-----------|------------------------------------|-------------------|----------------------------------------------|
| `%`       | Represents zero or more characters | `"LIKE 'A%'"`     | Anything starting with A (Anna, Alex, Arthur) |
| `_`       | Represents exactly one character   | `"LIKE '_at'"`    | Cat, Bat, Rat (but not Flat)                 |

### Example:
`"SELECT name FROM patients WHERE name LIKE 'J%';"`  
â†’ Finds all names that start with â€œJâ€ (like John, Jane, James).

`"SELECT name FROM patients WHERE name LIKE '%son';"`  
â†’ Finds names ending with â€œsonâ€ (like Johnson, Thomson).

`"SELECT name FROM patients WHERE name LIKE '%an%';"`  
â†’ Finds names containing â€œanâ€ anywhere (like Hannah, Andrea).

---

## ðŸ“ Using a Range

Instead of chaining multiple conditions (like `>=` and `<=`), you can use the **BETWEEN** operator â€” itâ€™s cleaner and easier to read.

**Syntax:**  
`"SELECT column_name FROM table_name WHERE column_name BETWEEN value1 AND value2;"`

### Example:
`"SELECT name, age FROM patients WHERE age BETWEEN 25 AND 40;"`  
â†’ Finds patients aged **25 to 40**, inclusive.

âœ… **Tip:**  
`BETWEEN` works with numbers, dates, and even text (alphabetically).

**Example with Dates:**  
`"SELECT * FROM appointments WHERE date BETWEEN '2025-11-01' AND '2025-11-10';"`

---

## ðŸ§© Using a Set of Values

If you want to match **specific values**, instead of typing many OR conditions, use the **IN operator**.

**Syntax:**  
`"SELECT column_name FROM table_name WHERE column_name IN (value1, value2, value3);"`

### Example:
`"SELECT name, department FROM staff WHERE department IN ('Radiology', 'Cardiology', 'Neurology');"`  
â†’ Finds all staff members in those three departments.

âœ… **Without IN:**  
`"WHERE department = 'Radiology' OR department = 'Cardiology' OR department = 'Neurology';"`  
ðŸ˜© Thatâ€™s too long â€” `IN` is much neater!

---

## âš¡ Quick Recap

| Feature            | Keyword    | What It Does                     | Example (String Form)                                                 |
|--------------------|------------|----------------------------------|----------------------------------------------------------------------|
| **String Pattern** | `LIKE`     | Finds text that matches a pattern| `"SELECT * FROM patients WHERE name LIKE 'A%';"`                     |
| **Range**          | `BETWEEN`  | Finds values within a range       | `"SELECT * FROM patients WHERE age BETWEEN 20 AND 30;"`              |
| **Set of Values**  | `IN`       | Matches any value from a list     | `"SELECT * FROM doctors WHERE department IN ('ENT', 'ER', 'ICU');"`  |

---

ðŸ’¬ **In short:**  
Use `LIKE` for **patterns**, `BETWEEN` for **ranges**, and `IN` for **lists** â€” your SQL searches will be cleaner, faster, and way more fun. ðŸ•µï¸â€â™€ï¸ðŸ’»

---

# ðŸ“Š Sorting Result Sets â€” Organize Your Data Like a Pro!

When you get results from a query, SQL doesnâ€™t guarantee any specific order â€” itâ€™s like a shuffled deck of cards ðŸƒ.  
If you want to **control the order** of your results, you use the **ORDER BY** clause.  
Itâ€™s your sorting tool â€” neat, powerful, and super easy to use. ðŸ˜Ž

---

## ðŸ§© ORDER BY Clause

Use **ORDER BY** to sort your result set in **ascending** (default) or **descending** order.

**Syntax:**  
`"SELECT column_name FROM table_name ORDER BY column_name ASC|DESC;"`

### Example 1 â€” Default (Ascending)
`"SELECT name, age FROM patients ORDER BY age;"`  
â†’ Sorts patients by **age**, from youngest to oldest.

### Example 2 â€” Descending
`"SELECT name, age FROM patients ORDER BY age DESC;"`  
â†’ Sorts patients by **age**, from oldest to youngest.

---

## ðŸ”¢ ORDER BY Column Number

Instead of typing the column name, you can sort using the **columnâ€™s position** in the SELECT statement.

**Syntax:**  
`"SELECT column1, column2 FROM table_name ORDER BY column_position;"`

### Example:
`"SELECT name, age, gender FROM patients ORDER BY 2;"`  
â†’ Sorts by the **second column** (age), in ascending order.

`"SELECT name, age, gender FROM patients ORDER BY 2 DESC;"`  
â†’ Sorts by the **second column** (age), in descending order.

âš ï¸ **Note:**  
Using column numbers can make your code shorter, but itâ€™s less readable.  
Itâ€™s best to use column names unless youâ€™re doing quick queries.

---

## âš¡ Quick Recap

| Feature                    | Keyword        | Description                              | Example (String Form)                                       |
|-----------------------------|----------------|------------------------------------------|--------------------------------------------------------------|
| **Sort by Column Name**     | `ORDER BY`     | Sorts results using a specific column    | `"SELECT name, age FROM patients ORDER BY age DESC;"`        |
| **Sort by Column Position** | `ORDER BY #`   | Sorts results by column number in SELECT | `"SELECT name, age FROM patients ORDER BY 2;"`               |
| **Ascending Order**         | `ASC`          | Sorts smallest to largest (default)      | `"SELECT * FROM products ORDER BY price ASC;"`               |
| **Descending Order**        | `DESC`         | Sorts largest to smallest                | `"SELECT * FROM products ORDER BY price DESC;"`              |

---

ðŸ’¬ **In short:**  
`ORDER BY` helps you **control the sequence** of your results â€” whether itâ€™s names alphabetically or prices from high to low.  
Your data, your order. ðŸ“ˆðŸ“‰

---

# ðŸ§® Grouping Result Sets â€” Summarize Like a Data Pro!

When youâ€™re working with large sets of data, you might want to **summarize** them instead of looking at every row.  
Thatâ€™s where **DISTINCT**, **GROUP BY**, and **HAVING** come in!  
They help you **eliminate duplicates**, **group similar data**, and **filter summaries** â€” all in one neat package. ðŸŽ

---

## ðŸš« Eliminating Duplicates with DISTINCT

By default, SQL shows *all* rows â€” even duplicates.  
To get **unique** results only, use the `DISTINCT` keyword.

**Syntax:**  
`"SELECT DISTINCT column_name FROM table_name;"`

### Example:
`"SELECT DISTINCT department FROM employees;"`  
â†’ Shows each department **once**, even if many employees belong to it.

### Example Table:

| employee_id | name       | department |
|--------------|------------|-------------|
| 1            | John Doe   | HR          |
| 2            | Jane Smith | HR          |
| 3            | Alex Cruz  | IT          |

âœ… **Result:**  
| department |
|-------------|
| HR          |
| IT          |

---

## ðŸ“Š GROUP BY â€” Summarizing Data

Use **GROUP BY** when you want to **aggregate** data â€” like totals, averages, or counts â€” per category.

**Syntax:**  
`"SELECT column_name, aggregate_function(column_name) FROM table_name GROUP BY column_name;"`

### Example:
`"SELECT department, COUNT(*) FROM employees GROUP BY department;"`  
â†’ Counts how many employees belong to each department.

### Example Table:

| department | COUNT(*) |
|-------------|----------|
| HR          | 2        |
| IT          | 1        |

âœ… **Common Aggregate Functions:**
| Function  | Description               | Example (String Form)                                  |
|------------|---------------------------|--------------------------------------------------------|
| `COUNT()`  | Counts rows               | `"SELECT COUNT(*) FROM employees;"`                    |
| `SUM()`    | Adds up numeric values    | `"SELECT SUM(salary) FROM employees;"`                 |
| `AVG()`    | Finds average value       | `"SELECT AVG(salary) FROM employees;"`                 |
| `MAX()`    | Finds the largest value   | `"SELECT MAX(age) FROM patients;"`                     |
| `MIN()`    | Finds the smallest value  | `"SELECT MIN(age) FROM patients;"`                     |

---

## ðŸ§  HAVING â€” Filtering Groups

The **HAVING** clause filters **grouped results** â€” similar to `WHERE`, but used *after* `GROUP BY`.

**Syntax:**  
`"SELECT column_name, aggregate_function(column_name) FROM table_name GROUP BY column_name HAVING condition;"`

### Example:
`"SELECT department, COUNT(*) FROM employees GROUP BY department HAVING COUNT(*) > 1;"`  
â†’ Shows only departments that have **more than one employee**.

### Step-by-step:
1. `GROUP BY` creates groups.  
2. `HAVING` filters those groups.  

âœ… **Tip:**  
Use `WHERE` to filter **rows** before grouping.  
Use `HAVING` to filter **groups** after aggregation.

---

## âš¡ Quick Recap

| Feature              | Keyword      | Description                                 | Example (String Form)                                                      |
|-----------------------|--------------|---------------------------------------------|----------------------------------------------------------------------------|
| **Eliminate Duplicates** | `DISTINCT` | Returns only unique rows                    | `"SELECT DISTINCT department FROM employees;"`                             |
| **Group Data**           | `GROUP BY` | Groups rows with the same values            | `"SELECT department, COUNT(*) FROM employees GROUP BY department;"`        |
| **Filter Groups**        | `HAVING`   | Filters results after grouping              | `"SELECT department, COUNT(*) FROM employees GROUP BY department HAVING COUNT(*) > 1;"` |

---

ðŸ’¬ **In short:**  
Use `DISTINCT` to get **unique** rows, `GROUP BY` to **summarize**, and `HAVING` to **filter summaries**.  
Together, they help turn raw data into clean insights! ðŸ“ˆâœ¨

