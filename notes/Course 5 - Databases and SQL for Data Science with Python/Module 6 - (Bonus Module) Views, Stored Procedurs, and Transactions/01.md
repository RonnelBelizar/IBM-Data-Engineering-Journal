# Topic: Module 6 ‚Äî Views, Stored Procedures, and Transactions

---

# üëÅÔ∏è Views in SQL

A **View** is like looking at your data through a clean window ‚Äî you don‚Äôt see the full table, only the parts you *want* to see.

---

## üí° What Is a View?

A **View** is a *virtual table* created from a SQL query.  
It **does not store data** by itself ‚Äî it only displays data from underlying tables.

You can think of it as a **saved SELECT statement**.

Example (String Form):  
"CREATE VIEW high_salary AS SELECT name, salary FROM employees WHERE salary > 50000;"

When you query the view:  
"SELECT * FROM high_salary;"

It behaves just like a table ‚Äî but the data comes from the original tables.

---

## üïí When to Use a View?

| Use Case                          | Explanation                                                                   |
|----------------------------------|-------------------------------------------------------------------------------|
| Simplifying complex queries       | Save long SELECT queries for easy reuse.                                      |
| Security and restricted access    | Hide sensitive columns (e.g., passwords, salary details).                      |
| Data abstraction                  | Users can query a simplified version of the database.                          |
| Logical separation                | Present data differently without altering physical tables.                     |
| Reusable reporting structures     | Perfect for dashboards and analytics queries.                                  |

---

## ‚ö° Example Use Cases (String Form)

**Simplify complex joins:**  
"CREATE VIEW employee_details AS SELECT e.name, d.department_name FROM employees e JOIN departments d ON e.dept_id = d.id;"

**Hide sensitive data:**  
"CREATE VIEW public_employees AS SELECT name, department FROM employees;"

**Create a cleaner lookup:**  
"CREATE VIEW active_orders AS SELECT * FROM orders WHERE status = 'active';"

---

üí¨ In short:  
A **View** is a powerful tool to simplify, secure, and organize your database queries ‚Äî without storing extra data. It‚Äôs clean, safe, and efficient!

---

# üß© Stored Procedures

## What Is a Stored Procedure?
A **stored procedure** is a saved block of SQL code stored inside the database.  
You can run it anytime using a single command.

Think of it like a function in Python ‚Äî but inside SQL.

**Example (String Form):**  
"CALL GetEmployees();"

## Benefits of Stored Procedures

| Benefit                    | Description                                                  |
|----------------------------|--------------------------------------------------------------|
| Reusability                | Write SQL logic once and reuse it many times.                |
| Performance                | Precompiled and stored, so it runs faster.                   |
| Security                   | Users call the procedure without accessing base tables.      |
| Simplifies Applications    | App code becomes smaller because SQL runs in the database.   |

---

## Creating a Stored Procedure

**Basic Syntax (String Form):**  
"DELIMITER $$"  
"CREATE PROCEDURE GetEmployees()"  
"BEGIN"  
"    SELECT * FROM employees;"  
"END $$"  
"DELIMITER ;"

This stored procedure simply returns all employees.

---

# üóÑÔ∏è Stored Procedures ‚Äî More Examples

Here are **clear and practical examples** of how stored procedures are used in SQL.  
All code is in **string format**, exactly as you requested.

---

## ‚≠ê Example 1: Simple Stored Procedure (No Parameters)

Creates a procedure that returns all employees.

"CREATE PROCEDURE GetAllEmployees()
BEGIN
    SELECT * FROM employees;
END;"

Call it:

"CALL GetAllEmployees();"

---

## ‚≠ê Example 2: Stored Procedure With Input Parameter

Returns employees whose salary is above a given value.

"CREATE PROCEDURE GetHighSalaryEmployees(IN min_salary INT)
BEGIN
    SELECT name, salary 
    FROM employees
    WHERE salary > min_salary;
END;"

Call:

"CALL GetHighSalaryEmployees(50000);"

---

## ‚≠ê Example 3: Stored Procedure With Multiple Parameters

Returns employees based on department and minimum salary.

"CREATE PROCEDURE GetEmployeesFilter(
    IN dept_name VARCHAR(50),
    IN min_salary INT
)
BEGIN
    SELECT name, department, salary
    FROM employees
    WHERE department = dept_name
    AND salary >= min_salary;
END;"

Call:

"CALL GetEmployeesFilter('IT', 40000);"

---

## ‚≠ê Example 4: Stored Procedure With OUT Parameter

Returns the total number of employees.

"CREATE PROCEDURE CountEmployees(OUT total INT)
BEGIN
    SELECT COUNT(*) INTO total FROM employees;
END;"

Call:

"CALL CountEmployees(@result);"
"SELECT @result;"

---

## ‚≠ê Example 5: Updating Data Using a Stored Procedure

Update employee salary by ID.

"CREATE PROCEDURE UpdateSalary(
    IN emp_id INT,
    IN new_salary INT
)
BEGIN
    UPDATE employees
    SET salary = new_salary
    WHERE id = emp_id;
END;"

Call:

"CALL UpdateSalary(3, 60000);"

---

## ‚≠ê Example 6: Insert Data Using a Stored Procedure

"CREATE PROCEDURE AddEmployee(
    IN emp_name VARCHAR(100),
    IN emp_dept VARCHAR(50),
    IN emp_salary INT
)
BEGIN
    INSERT INTO employees(name, department, salary)
    VALUES (emp_name, emp_dept, emp_salary);
END;"

Call:

"CALL AddEmployee('Ron', 'Engineering', 55000);"

---

## ‚≠ê Example 7: Stored Procedure With Conditional Logic

Procedure checks stock levels and returns status.

"CREATE PROCEDURE CheckStock(IN product_id INT)
BEGIN
    DECLARE stock_level INT;

    SELECT quantity INTO stock_level
    FROM inventory
    WHERE id = product_id;

    IF stock_level = 0 THEN
        SELECT 'OUT OF STOCK' AS status;
    ELSEIF stock_level < 10 THEN
        SELECT 'LOW STOCK' AS status;
    ELSE
        SELECT 'IN STOCK' AS status;
    END IF;
END;"

Call:

"CALL CheckStock(12);"

---

## ‚≠ê Example 8: Looping Inside a Stored Procedure

Counts numbers from 1 to N and stores sum.

"CREATE PROCEDURE SumToN(IN n INT, OUT total INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    SET total = 0;

    WHILE i <= n DO
        SET total = total + i;
        SET i = i + 1;
    END WHILE;
END;"

Call:

"CALL SumToN(10, @sum);"
"SELECT @sum;"

---

If you want **even more examples** like using:
- transactions inside stored procedures  
- cursors inside stored procedures  
- error handling inside stored procedures  
Just tell me ‚Äî I'll prepare them in the same format.  

---

# üîí ACID Transactions  
ACID is a set of properties that guarantee **safe, consistent, and reliable** database transactions.  
It ensures that even when many users or processes access the database at the same time, data remains correct.

---

## üß† What Are ACID Properties?

| Property      | Meaning                                                                 |
|----------------|-------------------------------------------------------------------------|
| **A ‚Äì Atomicity** | A transaction is *all or nothing*. If part fails, everything rolls back. |
| **C ‚Äì Consistency** | The database must move from one valid state to another valid state.       |
| **I ‚Äì Isolation** | Each transaction runs as if it's the only one in the system.               |
| **D ‚Äì Durability** | Once a transaction is committed, the data *will not be lost*, even after crashes. |

---

## üí° Example Explanations

### **Atomicity**
If you transfer ‚Ç±500 from Account A to Account B:  
1. Subtract 500 from A  
2. Add 500 to B  
These two must succeed together ‚Äî or not at all.

### **Consistency**
Balance totals, foreign keys, data types, constraints ‚Äî all must remain valid after the transaction.

### **Isolation**
Two users withdrawing money at the same time should not interfere with each other‚Äôs results.

### **Durability**
If the system crashes after a commit, the data must still be saved.

---

## ‚öôÔ∏è How ACID Transactions Work

Transactions commonly follow this pattern:

"START TRANSACTION;"  
"SQL statements here"  
"COMMIT;"  
-- or --  
"ROLLBACK;"

---

## üß™ Example: Safe Money Transfer

"START TRANSACTION;"  
"UPDATE accounts SET balance = balance - 500 WHERE id = 1;"  
"UPDATE accounts SET balance = balance + 500 WHERE id = 2;"  
"COMMIT;"

If anything fails:

"ROLLBACK;"

---

## üß± Example: Preventing Dirty Reads (Isolation)

"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;"  
"START TRANSACTION;"  
"SELECT * FROM inventory;"  
"COMMIT;"

---

## üîê Example: Insert With Guaranteed Durability

"START TRANSACTION;"  
"INSERT INTO logs(message) VALUES('System restart');"  
"COMMIT;"

This is now guaranteed safe even after a power failure.

---

## ‚ö° Summary Table

| ACID Property  | Why It Matters                                                          |
|----------------|-------------------------------------------------------------------------|
| Atomicity      | Prevents partial updates that corrupt data                               |
| Consistency    | Keeps the database valid after every transaction                         |
| Isolation      | Ensures correct results with multiple users                              |
| Durability     | Protects committed data against crashes                                  |

---

ACID transactions make databases **reliable, safe, and trustworthy**, especially in banking, healthcare, and any system where data accuracy is critical. üîêüíæ

# üè• ACID Transactions ‚Äî Healthcare Example (Single, Realistic Scenario)

## üíä Scenario: Updating a Patient‚Äôs Medication + Billing

A nurse updates a patient‚Äôs **medication record**, and at the same time the system must update the **billing table**.  
Both actions **must succeed together** ‚Äî or **fail together**.

This is a perfect case for an **ACID transaction**.

---

## üß™ ACID in Action (Atomicity, Consistency, Isolation, Durability)

### üéØ Goal
Add a new medication entry and charge the patient for it **as ONE transaction**.

If the billing fails, the medication must **NOT** be added.  
If the medication fails, the billing must **NOT** be added.

---

## ü©∫ Healthcare Example (String Form)

"START TRANSACTION;"

-- Step 1: Add medication administered  
"INSERT INTO MedicationRecords (patient_id, medication, dosage, nurse_id, time_given)  
 VALUES (101, 'Amoxicillin', '500mg', 12, '2025-11-17 10:15:00');"

-- Step 2: Add billing charge  
"INSERT INTO Billing (patient_id, amount, description, date)  
 VALUES (101, 850, 'Antibiotic Medication - Amoxicillin', '2025-11-17');"

-- If both succeed  
"COMMIT;"

-- If something fails  
"ROLLBACK;"

---

## ü©π Explanation  
- **Atomicity** ‚Üí Both inserts happen or none happen.  
- **Consistency** ‚Üí Patient records remain valid (no medication without billing, no billing without medication).  
- **Isolation** ‚Üí Other users can‚Äôt see partial updates while this is happening.  
- **Durability** ‚Üí After commit, the changes are permanently saved‚Äîeven if the system crashes.

---

This is a **realistic healthcare transaction** where ACID protects patient safety **and** financial accuracy.
